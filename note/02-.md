将封装好的 axios 放入项目中。

将区分环境部分，针对 webpack 做区分。

---

三种方式：1.手动切换；2.环境变量；3.配置文件。

2.webpack 环境遍历，process.env.NODE_ENV（'development' | 'production' | 'test' 联合类型）

```typescript
let BASE_URL = ''
if (process.env.NODE_ENV === 'development') {
	BASE_URL = '...'
} else {
	BASE_URL = '...'
}
```

进行测试，将项目打包 npm run build，

打包后发现终端给出提示，可以使用如下命令，去创建一个本地服务。

```shell
npm install -g server

serve -s build # 启动本地服务，并指定 build 目录下的文件，作为资源。
```

3.配置文件，必须以 “`REACT_APP_`” 前缀开头

.env.development

```
REACT_APP_BASE_URL = HAHA
```

.env.production

```
REACT_APP_BASE_URL = 'HEHE'
```

index.ts

```typescript
// 加载
console.log(process.env.REACT_APP_BASE_URL)
```

---

process.env 的类型来自哪里？

src\react-app-env.d.ts 文件所引用的位置

node_modules\react-scripts\lib\react-app.d.ts

```typescript
declare namespace NodeJS {
	interface ProcessEnv {
		readonly NODE_ENV: 'development' | 'production' | 'test'
		readonly PUBLIC_URL: string
	}
}
```

可以在上述位置，声明 REACT_APP_BASE_URL 的类型，但这样做不好，不要去修改源码。

而是在 src\react-app-env.d.ts 中进行声明

```typescript
declare namespace NodeJS {
	interface ProcessEnv {
		readonly REACT_APP_BASE_URL: string
	}
}
```

---

将拦截携带 token 部分注释。

---

[项目 API 文档](http://codercba.com:9002)

将 BASE_URL 改为该地址。

---

在 recommend 中发送网络请求，进行 axios 的测试。

给 useState 传入类型。使用 `useState<T>`

---

补充知识：

类组件中，TS 要怎么写？

普通写法：

```tsx
import React, { PureComponent } from 'react'

export class demo extends PureComponent {
	render(): React.ReactNode {
		return <div>demo</div>
	}
}

export default demo
```

为组件的 `props` 设置类型：

PureComponent 接受泛型。

```tsx
import React, { PureComponent } from 'react'

interface IProps {
	name: string
	age: number
}

export class Demo extends PureComponent<IProps> {
	render(): React.ReactNode {
		return (
			<div>
				<h1>name: {this.props.name}</h1>
				<h1>name: {this.props.age}</h1>
			</div>
		)
	}
}

export default Demo

```

为组件的 `state` 加上类型约束：

```tsx
import React, { PureComponent } from 'react'

interface IProps {
	name: string
	age: number
}

interface IState {
	msg: string
	count: number
}

export class Demo extends PureComponent<IProps, IState> {
	constructor(props: IProps) {
		super(props)
		this.state = {
			msg: 'haha',
			count: 0
		}
	}

	render(): React.ReactNode {
		return (
			<div>
				<h1>name: {this.props.name}</h1>
				<h1>name: {this.props.age}</h1>
			</div>
		)
	}
}

export default Demo
```

将 state 写在成员变量中进行初始化，就不用谢 constructor 了。

```tsx
import React, { PureComponent } from 'react'

interface IProps {
	name: string
	age: number
}

interface IState {
	msg: string
	count: number
}

export class Demo extends PureComponent<IProps, IState> {
	state = {
		msg: 'haha',
		count: 0
	}

	render(): React.ReactNode {
		return (
			<div>
				<h1>name: {this.props.name}</h1>
				<h1>name: {this.props.age}</h1>
			</div>
		)
	}
}

export default Demo
```

PureComponent 传入的第三个泛型（很少用），用于定义生命周期 getSnapshotBeforeUpdate 的返回值类型。

它的返回值，用于 componentDidUpdate 生命周期的第三个参数。

此时，需要使用 propsTypes 对 Demo 组件做 prop 类型验证。除非关闭 eslint 警告。

```tsx
import React, { PureComponent } from 'react'
import PropTypes from 'prop-types'

interface IProps {
	name: string
	age: number
}

interface IState {
	msg: string
	count: number
}

interface ISnaptShot {
	address: string
}

export class Demo extends PureComponent<IProps, IState, ISnaptShot> {
	state = {
		msg: 'haha',
		count: 0
	}

	static propTypes = {
		name: PropTypes.string,
		age: PropTypes.number
	}

	getSnapshotBeforeUpdate(prevProps: Readonly<IProps>, prevState: Readonly<IState>) {
		console.log(prevProps)
		console.log(prevState)

		return { address: 'LA' }
	}

	componentDidUpdate(
		prevProps: Readonly<IProps>,
		prevState: Readonly<IState>,
		snapshot?: ISnaptShot | undefined
	): void {
		console.log(prevProps)
		console.log(prevState)
		console.log(snapshot)
	}

	render(): React.ReactNode {
		return (
			<div>
				<h1>name: {this.props.name}</h1>
				<h1>name: {this.props.age}</h1>
			</div>
		)
	}
}

export default Demo

```

---

store 中 createSlice 里 initialState 一般不需要指定类型，可以自动推导。

手动指定类型的好处是，对于一些模糊的类型，可以明确指定。

```typescript
type DirectionType = 'left' | 'right' | 'down' | 'up'

interface IState {
	count: number
	message: string
	address: string
	height: number
	direction: DirectionType
}

const initialState: IState = {
	count: 100,
	message: 'hello redux',
	address: '深圳市',
	height: 1.88,
	direction: 'left'
}

const counterSlice = createSlice({
	name: 'counter',
	initialState,
	reducers: {
		changeMessageAction(state, { payload }) {
			state.message = payload
		}
	}
})
```

---

指定 reducers 中每个方法中，action 参数的类型，需要使用到 PyloadAction 泛型

```typescript
import { createSlice, PayloadAction } from '@reduxjs/toolkit'

//...

const counterSlice = createSlice({
	name: 'counter',
	initialState,
	reducers: {
		changeMessageAction(state, { payload }: PayloadAction<string>) {
			state.message = payload
		}
	}
})
```

