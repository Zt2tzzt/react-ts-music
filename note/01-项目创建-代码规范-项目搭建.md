创建项目，取名 react18-ts-music

两种方案

方案一：使用脚手架，创建一个普通项目，自行配置 TS，有以下弊端。

- React 的配置默认隐藏，需要使用 eject 弹出配置，且不可逆，很麻烦。
- React 项目配置有难度，最好配置 tsc 和 babel 两种编译方式，分别负责类型检测和编译时代码转换。

方案二：使用脚手架创建

```shell
# 使用脚手架，同时支持 TypeScript
create-react-app [项目名称] --template typescript
```

---

梳理目录结构，在 src 中保留三个文件

App.tsx

index.tsx

react-app-env.d.ts

---

配置 ICON

---

配置 title

- 在代码中动态修改
- 在 public/index.html 中修改。

---

路径别名修改，两种方案：

- eject，不推荐
- craco，项目中采用。

安装

```shell
npm install @craco/craco -D
```

创建 `craco.coinfig.js`，进行配置。

```javascript
const path = require('path')

const resolve = dir => path.resolve(__dirname, dir)

module.exports = {
	webpack: {
		alias: {
			'@': resolve('src')
		}
	}
}
```

修改 package.json 相关命令：

```json
{
  "scripts": {
    "start": "craco start",
    "build": "craco build",
    "test": "craco test",
    "eject": "react-scripts eject"
  },
}
```

---

上述操作后，使用“@”路径，ts 报错了，需要配置 tsconfig.json

```json
{
  "compilerOptions": {
    //...
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
}

```

---

配置 .editorconfig 文件。

---

配置 prettier

安装

```shell
npm install prettier -D
```

在 package.json 中添加 prettier 的命令。

创建 .prettierrc 或 .prettierrc.json 配置文件。

创建 .prettierignore 配置文件。

---

配置 eslint

安装

```shell
npm install eslint -D
```

使用自动化配置工具。

```shell
npx eslint --init

# 有以下选项
You can also run this command directly using 'npm init @eslint/config'.
Need to install the following packages:
  @eslint/create-config@0.4.2
Ok to proceed? (y) y
√ How would you like to use ESLint? · problems
√ What type of modules does your project use? · esm
√ Which framework does your project use? · react
√ Does your project use TypeScript? · No / Yes
√ Where does your code run? · browser
√ What format do you want your config file to be in? · JavaScript
The config that you've selected requires the following dependencies:

eslint-plugin-react@latest @typescript-eslint/eslint-plugin@latest @typescript-eslint/parser@latest
√ Would you like to install them now? · No / Yes
√ Which package manager do you want to use? · pnpm
```

为 .eslintrc.js 和 craco.config.js 上方添加注释，消除 eslint 警告。

---

eslint 和 prettier 的兼容性配置。

```shell
npm install eslint-plugin-prettier eslint-config-prettier -D
```

配置 .eslntrc.js

```javascript
module.exports = {
  //...
	extends: [
    //...
    'plugin:prettier/recommended'
	],
}
```

---

项目目录解构搭建

---

CSS 重置。

安装 normalize.css

```shell
npm i normalize.css
```

配置 less 支持：

安装 craco-less，项目中未安装，使用的 css/

```shell
npm i craco-less -D
```

配置 craco.config.js 文件

```javascript
const path = require('path')
const CracoLessPlugin = require('craco-less')

const resolve = pathName => path.resolve(__dirname, pathName)

module.exports = {
	// less
	plugins: [
		{
			plugin: CracoLessPlugin
		}
	],
```

编写重置的样式文件。

common.css, reset.css, index.css

---

router 配置

安装

```shell
npm i react-router-dom
```

创建 router 配置文件。确保是一个 tsx 文件才行。

src\router\index.tsx

```tsx
import React from 'react'

import Discover from '@/views/discover/Discover'
import type { RouteObject } from 'react-router-dom'

const routes: RouteObject[] = [
	{
		path: '/',
		element: <Discover></Discover>
	}
]

export default routes
```

创建 Discover.tsx

```tsx
import React, { memo } from 'react'

const Discover = memo(props => {
	return <div>Discover</div>
})

Discover.displayName = 'Discover'

export default Discover
```


> 每个用于 React 组件的 tsx 文件（包括 router 的配置文件），
>
> - 都要 import `React`
> - 如果使用箭头函数作为函数组件，推荐显式的为组件加上名称，如 `Discover.displayName = 'Discover'`
>
> 在开发工具中，把换行符调整为 lf。

---

对组件的 prop 类型做约束。

方式一

```tsx
interface IProps {
	aaa: string
	bbb: string
}
const Discover = memo((props: IProps) => {
	return <div>Discover</div>
})
```

方式二：

```tsx
interface IProps {
	aaa: string
	bbb: string
}
const Discover: React.FunctionComponent<IProps> = memo(props => {
	return <div>Discover</div>
})
```

方式三：

```tsx
interface IProps {
	aaa: string
	bbb: string
}
const Discover: React.FC<IProps> = memo(props => {
	return <div>Discover</div>
})
```

给 Discover 传入元素，需要在 IProps 中加入 children 属性，使用 `ReactNode` 类型

```tsx
import React, { memo, type ReactNode } from 'react'

interface IProps {
	aaa: string
	bbb: string
	children: ReactNode
}
const Discover: React.FC<IProps> = memo(props => {
	return <div>Discover</div>
})

Discover.displayName = 'Discover'

export default Discover
```

未 React 的 tsx 组件设置一个代码片段模板，放入编辑工具中。

```json
{
  
	"react typesccript template": {
		"prefix": "react-tsx",
		"body": [
			"import React, { memo } from 'react'",
			"import type { FC, ReactNode } from 'react'",
			"",
			"interface IProps {",
			"	children?: ReactNode",
			"}",
			"const ${1:App}: FC<IProps> = memo(props => {",
			"	return <div>${1:App}</div>",
			"})",
			"",
			"${1:App}.displayName = '${1:App}'",
			"",
			"export default ${1:App}",
			""
		],
		"description": "react typesccript template"
	}
}
```

---

创建四个组件，在路由中配置，使用懒加载。

Discover，Mine，Focus，Download。

使用路由懒加载，需要在应用路由的组件外层，包裹 `<Suspense>`

> 路由懒加载，怎么做的优化？（面试）

配置默认导航。 

在 App.jsx 中，编写 Link，用于路由跳转。

---

配置二级路由。创建组件。

在 discover 目录下，创建组件 Ailbum, Artist, Djradio, Ranking, Recommend, Songs

配置 discover 的二级路由。同样使用懒加载。

在 Discover 中，使用 Link 配置路由跳转，使用 `<Outlet>` 占位。

Outlet 外层使用 `<Suspense>` 包裹，避免切换路由时，整个二级路由区域闪烁。

---

状态管理配置。

安装

```shell
npm install @reduxjs/toolkit react-redux
```

在 store/index.ts 中进行配置。

在 index.tsx 中，最外层包裹 Provider，并使用 store 属性。

---

为状态管理添加模块。

配置一个 counterstore，并使用 rtk 配置

在 App.jsx 中使用。发现 state 没有类型，如何获取 state 的类型？分析如下代码：

```typescript
// 尝试如下写法。
const state store.getState()
type StateType = typeof state

type GetStateFnType = typeof store.getState
type StateType = ReturnType<GetStateFnType>
```

将动态获取类型的代码，抽取到 store/index.ts 中。

---

每次在使用 store 时，都要导入 state 的类型，似乎还是有点麻烦。

封装 useSelector 函数，自动推导 state 类型。

从 react-redux 中导入 TypedUseSelectorHook 接口，它是一个函数调用签名。使用它封装自动推导的 useSelector。[参考文档](https://cn.redux.js.org/tutorials/typescript-quick-start#%E5%AE%9A%E4%B9%89-hooks-%E7%B1%BB%E5%9E%8B)

---

在 App.tsx 中，使用 dispath 派发 action。

在 store/index.ts 中封装一个自己的 useDispatch（非必须，利于管理）

shallEqual 也恶意封装自己的。

---

理解函数调用签名中的泛型。test-type.ts 文件理解

